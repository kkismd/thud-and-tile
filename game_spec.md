## Thud & Tileゲーム (Rust CLI) - 開発仕様書

### 1. プロジェクト概要

Rust言語と`crossterm`ライブラリを使用して開発された、ターミナル上で動作するThud & Tileゲーム。標準的なテトリスの要素に加え、独自のブロック消去ルール、スコア計算、および重力システムを特徴とする。

### 2. コアゲームメカニクス

*   **盤面サイズ:** 幅10マス x 高さ20マス。
*   **テトリミノ:** 標準的な7種類のテトリミノ（I, O, T, L, J, S, Z）を使用。
*   **基本操作:**
    *   左右移動 (`←`, `→` キー)
    *   時計回り回転 (`↓` キー)
    *   半時計回り回転 (`↑` キー)
    *   ソフトドロップ (`Space` キー)
    *   ハードドロップ (`Shift` + `↓` キー)
*   **ゲームオーバー:** ブロックが盤面上部に積み上がるとゲームオーバー。
*   **ゲームサイクル** タイトル画面→ゲームプレイ→ゲームオーバー→タイトル画面。

### 3. 視覚表現とUI

*   **ブロック表現:** 各ブロックは `[]` で表現され、前景色で色付けされる。
*   **テトリミノの色:**
    *   使用色はシアン、マゼンタ、イエローの3色のみ。
    *   各テトリミノは4つのブロックで構成され、出現時にこれら3色からランダムに割り当てられる（1つのテトリミノ内で4つのブロックは異なる色を持ち、かつ隣接するブロックは異なる色を持つ）。
    *   回転時もブロックの色は固定され、位置に応じて色が入れ替わる。
*   **壁の色:** 盤面の枠線は灰色で表示され、ブロックと区別しやすい。
*   **落下位置予測 (ゴースト):**
    *   現在落下中のテトリミノの最終着地点が `::` の文字で表示される。
    *   ゴーストの色は、その位置に着地するブロックの色と同じ。
*   **ライン消去アニメーション:**
    *   アニメーション中のブロックは、元の色を反転させた色で表示される。
    *   アニメーション速度は1ステップあたり120ミリ秒。
*   **UI表示:**
    *   得点が盤面右側に表示される。
    *   その下にNEXTミノが表示される

### 4. カスタムルール

*   **ミノの着地時の盤面の変化**
    1. ブロックが着地するたびに固定ブロックがスキャンされ、上下左右に同じ色が隣接している場合はブロックが数字に変化する。
    2. 数字は、そのブロックが同色のブロックと何個連結しているかを表す数
    3. 数字はバックグラウンドがそのブロックの色で文字色は黒

*   **得点システム**
    1. 得点はブロック消去で加算されるSCOREと、連結ボーナスを示すCHAIN-BONUS（UI上は`10-CHAIN`として表示）、および色別のMAX-CHAINがある
    2. SCOREは合計値のみを管理する（色別管理は行わない）
    3. SCOREはブロックの消去によって加算される整数値で、ライン消去のたびに加算される
    4. SCOREの計算方法は `消去されるブロックの数字 × その色のMAX-CHAIN値 × 10点` の合計
    5. MAX-CHAINは色別に管理され、同色ブロックの連結数のゲームプレイ中での最大値
        - MAX-CHAIN(CYAN), MAX-CHAIN(MAGENTA), MAX-CHAIN(YELLOW)
        - ミノが着地するたびに更新される
    6. CHAIN-BONUSは連結グループボーナスで獲得したSolidライン消去可能段数を表す
        - ピース着地時（`lock_piece()`処理中）に、連結数スキャン後に計算・加算される
        - 10個以上の連結グループがあれば、`floor(連結数 / 10)` 段分が加算される
    - 複数のグループがある場合は累積される
    - 上限は存在せず、獲得分はすべて保持される
        - ライン消去アニメーション終了後、実際にSolidラインを消去する際に使用される
        - 使用後は残った分が持ち越される（例：12段保有、2段使用 → 10段残る）
        - Solidラインが存在しない場合は消費されず、次回に持ち越される
    7. 画面上での表示は下記のようになる
```
SCORE:         1120
10-CHAIN:        17

MAX-CHAIN:
  CYAN:    12
  MAGENTA:  4
  YELLOW:  15
```
    8. CHAIN-BONUSの表示仕様
    - UIではラベル`10-CHAIN`と数値を右詰め表示する
        - 数値は現在保有しているSolidライン消去可能段数を表し、10段単位ではなく累積値がそのまま表示される
        - ラベルは固定文字列で、値が増減しても形式は変化しない

*   **ライン消去後の演出と得点計算:** ラインが揃ったとき、以下のような演出が行われる
    1. 揃ったすべてのラインのブロックが点滅する
    2. 揃ったラインが最下段でない場合
        1. 揃ったラインよりも下にあるブロックを調べる
        2. 上下左右に同じ色がない（つまり数字に変化していない）ブロックが消える（無得点）
    3. **【連結グループボーナス - ソリッドライン消去】**
        1. 盤面全体をスキャンし、同色で連結しているブロックのグループを検出する
        2. 連結数が10個以上のグループがある場合、以下のボーナス処理を行う：
            - 10～19個のグループ: 1グループにつきSolidライン1段を消去
            - 20～29個のグループ: 1グループにつきSolidライン2段を消去
            - 30～39個のグループ: 1グループにつきSolidライン3段を消去
            - 以降も10個刻みで消去段数が+1される（N段 = floor(連結数 / 10)）
        3. 複数のグループが条件を満たす場合、消去段数は累積される
        4. Solidラインは最下段から順に消去される
        5. 消去されたSolidラインの分だけフィールドの高さが回復する
        6. この処理は得点には影響しない（ボーナス処理のみ）
    4. 揃ったすべてのラインのブロックが固定ブロック（Solid）になる
    5. 固定ブロック（Solid）になったラインは、互いの間隔を保ったまま、残っているブロックを1段ずつ消しながら一番下のSolidラインの上に下がっていくアニメーションを行う
    6. 下がっていくラインはSolidラインに着地すると停止する。複数のラインが間を開けて下がっていくとき、下のラインが停止しても上のラインは下がり続けて間隔が詰まり、最後には下がりきったラインがすべて隣接する。
    7. 固定ブロック（Solid）のラインが一番下の段に達したらそのまま残り、フィールドの高さがそのラインの数だけ減る
    8. 次のラインが落下するときは底辺のSolidラインの上に積み重なり、フィールドがまたSolidラインの数だけ減る
    9. フィールドがどんどん浅くなり、フィールドがすべて埋まったらゲームオーバー

### 5. 技術的詳細と実装ノート

*   **言語:** Rust
*   **ターミナル操作ライブラリ:** `crossterm`
*   **入力ハンドリング:**
    *   ノンブロッキング入力。
    *   先行入力を受け付けて移動・回転のタイミングで反映する。
*   **描画:**
    *   `prev_state`と`state`を比較し、差分のみを描画する方式（ちらつき防止）。
    *   アニメーション終了後の画面クリーンアップを明示的に行う。
*   **テスト:**
    *   `#[cfg(test)]`モジュール内にユニットテストを実装。

### 6. 開発の方針

*    開発時の対話は日本語で行う
*    TDDのred-green-refactorのサイクルで開発する
*    cargo testでテストを実施する
*    cargo clippyとcargo fmtでコードの品質を担保する
*    TDDの1サイクルが終わるたびにcargo check, cargo test, cargo clipply, cargo fmtを実行してからgit add, commitする
*    non tracking fileをgit addする場合は理由を説明する
*    コミット前に`game_spec.md`のTDD計画を更新して、完了したタスクにチェックを入れる
*    改行を含むコミットメッセージはコマンドラインで失敗しやすいので一時ファイル経由で登録する
*    コミットメッセージは日本語で記載する
*    ソースコードを修正したときだけcargoコマンドで検査を行う
*    TDDのRefactorではRed/Greenで追加したテストを削除しない
*    コードを変更しようとする場合は必ず内容を説明する

---

### バグリスト

*    なし

---

### 改善点リスト

*    SCOREの得点方法を **得点システム** に書いた方法に変えたい

---

### 全体的なコードベースのリファクタリング計画 - 優先順位付け

**目的:** コードの可読性、保守性、拡張性を向上させ、将来の機能追加や変更を容易にする。安全でシンプルな変更から着手し、リスクを最小限に抑える。

**優先順位:**

**1. `Animation` enum の `count` フィールドのセマンティクス**
    *   **理由:** `Animation::LineBlink` の `count` フィールドの意図を明確にし、コードの可読性を向上させます。構造変更を伴うため、影響範囲は中程度です。
    *   **リファクタリング案:** `Animation::LineBlink` に `is_on: bool` のようなより明確なフィールドを追加し、その変更が影響する箇所（アニメーション処理ロジック）を更新する。
    *   **評価:** 危険性: 中。

**2. `GameState` の `is_valid_position` メソッドの改善**
    *   **理由:** ゲームのコアロジックに深く関わるため、最も慎重な変更が必要です。このメソッドの変更は、ゲームの動作に直接的な影響を与える可能性があります。
    *   **リファクタリング案:** ロジックを整理し、境界チェックと衝突チェックを別々のプライベートヘルパー関数に分割する。
    *   **評価:** 危険性: 中。
